JSON 压缩。

#### 数据格式

大体有两种表示字符的数据。

1. 原字符：共 7 bit 存储。

    0 分隔字符，1~26 'A' ~ 'Z'，27~52 'a' ~ 'z', 53 ~ 62 '0' ~ '9', 63 '_'；

    之后的编码为特殊字符。

2. 哈夫曼树编码

**如果知道下一个字符的类型/在哪个哈夫曼树里面，则唯一确定结束位置。**

#### 压缩格式

**特殊字符记录：**

将打算压缩的字符用一个新编码表示。

字符串分隔符为 0，结束为两个 0。

---

**key 哈夫曼树：**

存储哈夫曼树。**注意这里也要存一个分隔 JSON 的分隔符。**

存储方式：通过 01 序列遍历哈夫曼树，如果是 0 代表此节点是叶子节点，跳上去的同时后续是此叶子节点的信息。

叶子节点后紧接着节点信息，先存储字符串（以 0 结尾），再存储 value 数据类型（8bit，前 6 个表示数据存储长度，最后两个先后表示是否是有符号数（1 signed）、是否放入 value huffman 树）

---

**value 哈夫曼树：**

存储哈夫曼树。基本和 key 哈夫曼树相同，存储节点信息稍有不同。

叶子节点后紧接着节点信息，先使用 2bit 存储长度（分别为 1 2 4 8 byte），再存储 value 数据。注意这里无需考虑有无符号，由 key 类型的标记具体计算。

---

**主内容：**

对于非 array 类型 key，使用 key - value 交叉存储方式，则只需要保证能知道当前读数在哪里结束即可，哈夫曼编码可以满足要求；

对于 array 类型 key，将之后的 value 拆分成 length - value 方式来存储。对于二维数组，则是 length (dim 1) - length (dim 2) - value。

注意这里 length 不加入哈夫曼树，用 3bit(?) 存储。

如何压缩 value/key：

首先因为 key 和 value 是交叉进行的，直接分开建哈夫曼树。

key 哈夫曼树直接用 key index 相关信息建立即可。

对于 value 哈夫曼树，由于在 key 中会记录变量类型，此处只用记录 unsigned value 即可。

**这样的话可以支持不同类型但正值相同的 value 在压缩时被视为同一个**（TODO：这样做是否确实优秀？以及负值需不需要考虑）

之后，用哈夫曼树编码即可。

之后存 key_index - value。

#### 数据结构

huffman 树。

先支持离线编码。之后二分离线 or 支持在线加入

#### 算法流程

首先读入固定长度的 JSON 文件。

读入之后，先获取所有 key，做出特殊字符，将所有替换特殊字符后 key 的集合（不重复）建立哈夫曼树。

key 哈夫曼树建立：

哈夫曼树的作用是提供最终的编码和输出自己的结构。

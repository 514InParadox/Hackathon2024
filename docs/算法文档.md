JSON 压缩。

#### 算法流程

#### 压缩格式

**特殊字符记录：**

将打算压缩的字符用一个新编码表示。

一个字符用 7 个 bit 表示。（暂定，等水番茄测完）

字符串分隔符为 7'b000_0000，结束为两个 7'b000_0000。

0 分隔字符，1~26 'A' ~ 'Z'，27~52 'a' ~ 'z', 53 ~ 62 '0' ~ '9', 63 '_'

---

**key 哈夫曼树：**

存储哈夫曼树。注意这里也要存一个分隔 JSON 的分隔符。

每个的格式：先 para 长度表示位长，然后 key 以 7'b000_0000 结尾，然后 9bit 表示 key 的数据类型（位数+数组维数+value 是否是哈夫曼树）。

---

**value 哈夫曼树：**

对于标记 key 是哈夫曼树的 value，直接使用哈夫曼树找（无需声明长度）；否则直接拿值（长度已在 key 类型中给出）。

---

**主内容：**

对于非 array 类型 key，使用 key - value 交叉存储方式，则只需要保证能知道当前读数在哪里结束即可，哈夫曼编码可以满足要求；

对于 array 类型 key，将之后的 value 拆分成 length - value 方式来存储。对于二维数组，则是 length (dim 1) - length (dim 2) - value。

如何压缩 value/key：

首先因为 key 和 value 是交叉进行的，直接分开建哈夫曼树。

key 哈夫曼树直接用 key index 相关信息建立即可。

对于 value 哈夫曼树，由于在 key 中会记录变量类型，此处只用记录 unsigned value 即可。

**这样的话可以支持不同类型但正值相同的 value 在压缩时被视为同一个**（TODO：这样做是否确实优秀？以及负值需不需要考虑）

之后，用哈夫曼树编码即可。

之后存 key_index - value。

#### 数据结构

huffman 树。

先支持离线编码。之后二分离线 or 支持在线加入

